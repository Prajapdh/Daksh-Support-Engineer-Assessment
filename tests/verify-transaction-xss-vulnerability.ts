import 'dotenv/config';
import { accountRouter } from "@/server/routers/account";
import { createCallerFactory } from "@/server/trpc";
import { db } from "@/lib/db";
import { users, accounts, transactions } from "@/lib/db/schema";
import { eq } from "drizzle-orm";

async function verifyXSSVulnerability() {
    console.log("Starting XSS vulnerability verification script...");

    // 1. Create a test user
    const timestamp = Date.now();
    const testUser = {
        email: `test-xss-${timestamp}@example.com`,
        password: "Password123!",
        firstName: "Test",
        lastName: "User",
        phoneNumber: "1234567890",
        dateOfBirth: "1990-01-01",
        ssn: `ssn-xss-${timestamp}`,
        address: "123 Test St",
        city: "Test City",
        state: "CA",
        zipCode: "12345",
    };

    const insertedUser = await db.insert(users).values(testUser).returning().get();
    console.log(`Created test user with ID: ${insertedUser.id}`);

    // 2. Create Context
    const ctx = {
        req: { headers: { get: () => "" } },
        res: {
            setHeader: (key: string, val: string) => { },
            set: (key: string, val: string) => { }
        },
        user: { id: insertedUser.id },
    };

    const createCaller = createCallerFactory(accountRouter);
    const caller = createCaller(ctx as any);

    // 3. Create an account
    const account = await caller.createAccount({ accountType: "checking" });
    console.log(`Created account: ${account.accountNumber}`);

    // 4. Create a transaction with malicious description
    // Directly inserting via DB because the API might not allow setting description directly or it might be auto-generated in some cases.
    // However, looking at the schema or router might be needed. 
    // Let's assume for now we can simulate a transaction coming from the system or a third party with a malicious description.
    // Actually, looking at `fundAccount`, it creates a transaction. 
    // Does `fundAccount` allow setting description? 
    // Let's check `accountRouter` or just insert via DB for the test to ensure the data is there.
    // The vulnerability is in *rendering*, so it doesn't matter *how* it got there for this test, 
    // but demonstrating it via API is better if possible. 
    // If we can't via API, we insert via DB. 
    // Let's safe bet: insert via DB to ensure we have the EXACT malicious payload we want.

    const maliciousPayload = `<img src=x onerror=alert('XSS')>`;
    const safePayload = `Payment for <script>alert(1)</script>`;

    // We will insert 2 transactions
    await db.insert(transactions).values([
        {
            accountId: account.id,
            amount: 100,
            type: "deposit",
            description: maliciousPayload,
            status: "completed",
            createdAt: new Date().toISOString(),
        },
        {
            accountId: account.id,
            amount: 50,
            type: "withdrawal",
            description: safePayload,
            status: "completed",
            createdAt: new Date(Date.now() - 1000).toISOString(),
        }
    ]);

    console.log("Inserted transactions with potentially malicious descriptions.");

    // 5. Fetch transactions
    console.log("Fetching transactions...");
    const txs = await caller.getTransactions({ accountId: account.id });

    // 6. Verify assertions
    try {
        const maliciousTx = txs.find(t => t.description === maliciousPayload);
        const scriptTx = txs.find(t => t.description === safePayload);

        if (!maliciousTx || !scriptTx) {
            throw new Error("Failed to retrieve inserted transactions");
        }

        console.log("successfully retrieved transactions with HTML content.");
        console.log("Malicious Payload stored:", maliciousTx.description);
        console.log("Script Payload stored:", scriptTx.description);

        console.log("User credentials for manual verification:");
        console.log(`Email: ${testUser.email}`);
        console.log(`Password: ${testUser.password}`);

    } catch (e: any) {
        console.error("FAIL: Verification failed.", e.message);
        process.exit(1);
    }
    // We do NOT cleanup so we can manually verify
}

verifyXSSVulnerability().catch(console.error);
